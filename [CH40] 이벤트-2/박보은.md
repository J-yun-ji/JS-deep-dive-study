# 40장 - 이벤트2

# 이벤트 객체

이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성

생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.

이벤트 객체를 전달 받으려면 매개변수를 명시적으로 선언해야 한다.

아래 예제에선 e라는 이름으로 매개변수를 선언했으나 다른 이름을 사용해도 상관없다.

```jsx
<!DOCTYPE html>
<html>
<body>
<p>클릭하세요</p>
<em class="message">클릭한 곳의 좌표가 표시됩니다.</em>
<script>
	const $msg = document.querySelector('.message');
	// 클릭했을 때 마우스 좌표를 얻는 함수
	function showCoords(e) {
		$msg.textContent = `clientX : ${e.clientX}, clientY : ${e.clientY}`;
	}
	
	document.onclick = showCoords;
</script>
</body>
</html>
```

**이벤트 핸들러 어트리뷰트 방식**으로 이벤트 핸들러를 등록했다면 

**이벤트 핸들러의 첫 번째 매개변수 이름이 반드시 event**이어야 한다.

event가 아닌 다른 이름으로 매개변수를 선언할 경우 이벤트 객체를 전달받지 못한다.

```jsx
<!DOCTYPE html>
<html>
<body onclick=showCoords(event)>
<p>클릭하세요</p>
<em class="message">클릭한 곳의 좌표가 표시됩니다.</em>
<script>
	const $msg = document.querySelector('.message');
	// 클릭했을 때 마우스 좌표를 얻는 함수
	function showCoords(e) {
		$msg.textContent = `clientX : ${e.clientX}, clientY : ${e.clientY}`;
	}
	
	document.onclick = showCoords;
</script>
</body>
</html>
```

이벤트 객체

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled.png)

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled%201.png)

## 이벤트 객체의 상속 구조

이벤트가 발생하면 이벤트 타입에 따라 다양한 타입의 이벤트 객체가 생성된다.

Event 인터페이스에는 **모든 이벤트 객체의 공통 프로퍼티가 정의**되어 있고, 하위 인터페이스(FocusEvent, KEyboardEvent, MouseEvent, WheelEvent 등 )에 따라 **고유한 프로퍼티가 정의**되어 있다.

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled%202.png)

```jsx
const e = new InputEvent("change");
```

## 이벤트 객체의 공통 프로퍼티

**Event** 인터페이스에 정의되어 있는 이벤트 관련 프로퍼티는 파생 이벤트 객체에 상속된다.

| 공통 프로퍼티 | 설명 | 타입 |
| --- | --- | --- |
| type | 이벤트 타입 | string |
| target | 이벤트를 발생시킨 DOM 요소 | DOM 요소 노드 |
| currentTarget | 이벤트 핸들러가 바인딩된 DOM 요소 | DOM 요소 노드 |
| eventPhase | 이벤트 전파 단계 | number |
| bubbles | 이벤트를 버블링으로 전파하는지 여부 | boolean |
| cancelable | 이벤트의 기본 동작을 취소할 수 있는지 여부 | boolean |
| defaultPrevented | preventDefault 메서드를 호출해서 이벤트를 취소했는지 여부 | boolean |
| isTrusted | 사용자의 행위에 의해 발생한 이벤트인지 여부 | boolean |
| timeStamp | 이벤트가 발생한 시각 | number |

target 프로퍼티는 이벤트를 직접 건 요소를 가리킨다.

currentTarget 프로퍼티는 이벤트가 실행된 요소를 가리킨다.

```jsx
	$button.addEventListener('click', (e) => {
		console.log(e.target); // $button
		console.log(e.currentTarget ); // $button
	});
```

보통 target 프로퍼티와 currentTarget 프로퍼티는 동일한 DOM 요소를 가리키지만, 이벤트 위임을 사용한다면 서로 다른 DOM 요소를 가리킬 수 있음에 유의하자.

## 마우스 정보 취득

**MouseEvent** 생성자 함수(`click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseenter`, `mouseleave` 이벤트)의 고유 프로퍼티

- 마우스 포인터의 **좌표 정보**
    - screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
- **버튼 정보**
    - altKey, ctrlKey, shiftKey, button

## 키보드 정보 취득

**KeyboardEvent** 생성자 함수(`keydown`, `keyup`, `keypress` 이벤트)의 고유 프로퍼티

- altKey, ctrlKEy, metaKey, key, keyCode
    - key프로퍼티와 입력한 키의 대응관계  참고: [https://keycode.info](https://keycode.info/)

# 이벤트 전파

DOM 요소 노드에서 생성된 **이벤트 객체**는 이벤트를 발생시킨 DOM 요소인 **이벤트 타깃을 중심으로** **DOM 트리를 통해 전파**된다.

아래 이미지는 li에 클릭 이벤트를 줬을 때 이벤트 전파 과정을 보여준다.

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled%203.png)

이벤트 전파는 **전파 방향**에 따라 **3단계**로 구분된다.

1. 캡쳐링 단계 Capturing Phase : 이벤트가 상위 요소 → 하위 요소로 전파
2. 타깃 단계 Target Phase : 이벤트가 이벤트 타깃에 도달
3. 버블링 단계 Bubbling Phase : 이벤트가 하위 요소 → 상위 요소로 전파이벤트 핸들러 별 전파 단계

이벤트 핸들러 등록 방식에 따라 캐치할 수 있는 이벤트 전파 단계가 다르다.

1. 이벤트 핸들러 어트리뷰트 : 타깃 단계 / 버블링 단계 캐치
2. 이벤트 핸들러 프로퍼티 : 타깃 단계 / 버블링 단계 캐치
3. 이벤트 핸들러 addEventListener 메서드 : 타깃 단계 / 버블링 단계 / **캡쳐링** 단계(선별적 캐치)
    - 캡처링 단계를 캐치하려면 메서드의 **3번째 인수**를 **true**로 전달해야 한다.

이처럼 이벤트는 이벤트 타깃은 물론 상위 DOM요소에서도 캐치할 수 있다.

대부분의 이벤트는 캡처링과 버블링을 통해 전파되지만, 다음의 이벤트들은 버블링을 통해 전파되지 않는다.

이벤트 객체의 공통 프로퍼티 event.bubbles 는 false이다.

- **포커스 이벤트**: focus / blur
- **리소스 이벤트:** load / unload / abort / error
- **마우스 이벤트:** mouseenter / mouseleave

위 이벤트들은 버블링되지 않으므로 이벤트 타깃의 상위 요소에서 이벤트를 캐치하려면 캡처링 단계의 이벤트를 캐치 해야 한다. 하지만 반드시 위 이벤트를 상위 요소에서 캐치해야 한다면 대체할 수 있는 이벤트가 존재한다.

 아래 이벤트는 버블링을 통해 전파되므로 이벤트 객체의 공통 프로퍼티 event.bubbles 는 true이다.

- **포커스 이벤트**: focusin / focusout
- **마우스 이벤트:** mouseover / mouseout

```jsx
<!DOCTYPE html>
...
<body>
<p>
		버블링과 캡쳐링 이벤트 
		<button>버튼</button>
</p>
<script>
	// 버블링 단계의 이벤트 캐치
	document.body.addEventListener('click', () => {
		console.log('Handler for body');
	});
	
	// 캡처링 단계의 이벤트 캐치
	// addEventListener의 세 번재 인수 true를 전달하여 캡쳐링 단계에서 이벤트 캐치
	document.queerySelector('p').addEventListener('click', () => {
		console.log('Handler for paragraph');
	}, true);
	
	// 타깃 단계의 이벤트 캐치
	document.querySelector('button').addEventListener('click', () => {
		console.log('Handler for button');
	})
</script>
</body>
...
```

버튼 요소를 클릭할 경우

```jsx
Handler for paragraph // 캡처링 단계의 이벤트 캐치
Handler for button // 타깃 단계의 이벤트 캐치
Handler for body // 버블링 단계의 이벤트 캐치
```

p 요소를 클릭할 경우

```jsx
Handler for paragraph // 캡처링 단계의 이벤트 캐치
Handler for body // 버블링 단계의 이벤트 캐치
```

# 이벤트 위임

여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 **하나의 상위 DOM 요소에 이벤트 핸들러를 등록**하는 방법을 말한다.

이벤트 위임을 통해 이벤트를 등록할 경우 이벤트 객체의 target 프로퍼티를 사용하여 원하는 요소에 이벤트를 발생시킨다.

```jsx
...
<body>
	<ul id="fruits">
		<li>banana</li>
		<li>apple</li>
		<li>strawberry</li>
	</ul>
	
	<script>
		const fruits = document.getElementById('fruits');
		fruits.onclick = active;
		
		function active({target}) {
			if(!target.matches('#fruits > li')) return;
			
			[...$fruits.children].forEach($fruit => {
				$fruit.classList.toggle('active', $fruit === target);
			})
		}
	</script>
</body>
...
```

# DOM 요소의 기본 동작 조작

## DOM 요소의 기본 동작 중단

event 객체의 `preventDefault` 메서드는 **DOM 요소의 기본 동작을 중단**시킨다.

```jsx
document.queryselector('a').onclick = e => {
	// a 요소의 기본 동작을 중단한다.
	e.preventDefault();
}
```

## 이벤트 전파 방지

event 객체의 `stopPropagation` 메서드는 **이벤트 전파를 중지 시킨다**.

```jsx
// 이벤트 위임. 클릭된 하위 버튼 요소의 color를 변경한다.
document.queryselector('.container').onclick = ({ target }) => {
	if(!target.matches('.container > button')) return;
	target.style.color = 'red';
}

// .btn2 요소는 이벤트를 전파하지 않으므로 상위 요소에서 이벤트를 캐치할 수 없다.
document.queryselector('.btn2').onclick = e => {
	e.stopPropagation();
	e.target.style.color = "blue";
}
```

# 이벤트 핸들러 내부의 this

## 이벤트 핸들러 어트리뷰트 방식

이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 암묵적으로 이벤트 핸들러의 문으로 생성된다. 이벤트 핸들러에 의해 **일반 함수로 호출되며** 일반 함수 내부의 **this**는 **전역 객체 window를 가리킨다.**

```jsx
<button onclick="handleclick()">Click Me</button>

...
function handleClick() {
	console.log(this); //**window**
}
```

이벤트 핸들러를 호출할 때 인수로 전달한 this는 **이벤트를 바인딩한 DOM 요소를 가리킨다**.

인수로 전달한 this는 **암묵적으로 생성된 이벤트 핸들러 내부의 this**다

```jsx
<button onclick="handleclick(this)">Click Me</button>

...
function handleClick(button) {
	console.log(button); // button 요소
	console.log(this); // window
}
```

## 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 **DOM 요소**를 가리킨다.

1. 이벤트 핸들러 프로퍼티 방식
    
    ```jsx
    $button1.onClick = function (e) {
    	console.log(this); // $button1
    	console.log(e.currentTarget); // $button1
    	console.log(this === e.currentTarget); // true
    }
    ```
    
2. addEventListener 메서드 방식
    
    ```jsx
    $button2.addEventListener('click', function (e) {
    	console.log(this); // $button2
    	console.log(e.currentTarget); // $button2
    	console.log(this === e.currentTarget); // true
    }
    ```
    

**화살표 함수**로 정의한 이벤트 핸들러 내부의 this는 **상위 스코프의 this를 가리킨다**. 

화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.

1. 이벤트 핸들러 프로퍼티 방식
    
    ```jsx
    $button1.onClick = e => {
    	console.log(this); // window
    	console.log(e.currentTarget); // $button1
    	console.log(this === e.currentTarget); // false
    }
    ```
    
2. addEventListener 메서드 방식
    
    ```jsx
    $button2.addEventListener('click', e => {
    	console.log(this); // window
    	console.log(e.currentTarget); // $button2
    	console.log(this === e.currentTarget); // false
    }
    ```
    

**클래스**에서 이벤트 핸들러를 바인딩할 경우 this에 주의해야 한다.

**이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리키기 때문에** increase 메서드 내부의 this는 this.$button을 가리킨다.

```jsx
class App {
	constructor() {
		this.$button = document.querySelector('.btn');
		this.count = 0;

		this.$button.onclick = this.increase;
	}

	increase() {
		// 이벤트 핸들러 increase 내부의 this는 DOM 요소(this.$button)를 가리킨다.
		// this.$button은 this.$button.$button과 같다.
		this.$button.textContent = ++this.count;
		//TypeError: Cannot set property 'textContent' of undefined
	}
}
```

1. **bind 메서드 사용하여 해결**

increase 메서드를 이벤트 핸들러로 바인딩할 때 `bind` 메서드를 사용해 increase 메서드 내부의 this가 클래스가 생성할 인스턴스를 가리키도록 해야 한다.

```jsx
class App {
	constructor() {
		this.$button = document.querySelector('.btn');
		this.count = 0;

		this.$button.onclick = this.increase.bind(this);
	}

	increase() {
		this.$button.textContent = ++this.count;
	}
}
```

1.  **화살표 함수 사용하여 해결**

화살표 함수를 이벤트 핸들러로 등록하여 이벤트 핸들러 내부의 this가 인스턴스를 가리키도록 할 수 있다.

이때 이벤트 핸들러 increase는 프로토타입 메서드가 아닌 **인스턴스 메서드가 된다.**

```jsx
class App {
	constructor() {
		this.$button = document.querySelector('.btn');
		this.count = 0;

		this.$button.onclick = this.increase;
	}

	// inscrease는 인스턴스 메서드이며, 내부의 this는 인스턴스를 가리킨다.
	increase = () => this.$button.textContent = ++this.count;
}
```

# 이벤트 핸들러에 인수 전달

- 이벤트 핸들러 어트리뷰트 방식
    
    함수 호출문으로 인수를 전달한다
    
    ```jsx
    const checkUserNameLength = min => {
    	$msg.textContent = $input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : '';
    };
    
    $input.onblur = function() {
        checkUserNameLength(5);
    };
    
    $input.onblur = () => checkUserNameLength(5);
    ```
    

- 이벤트 핸들러 프로퍼티 방식 & addEventListener 메서드
    
    브라우저가 이벤트 핸들러를 호출하기 때문에 **함수 자체**를 등록해야 하므로 인수를 전달할 수 없다. 대신 이벤트 핸들러 내부에서 **함수를 호출하면서 인수를 전달할 수 있다.**
    
    ```jsx
    const checkUserNameLength = min => {
    	$msg.textContent = $input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : '';
    };
    
    $input.addEventListener('blur', () => {checkUserNameLength(5)})'
    ```
    
    혹은 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수 있다.
    
    ```jsx
    const checkUserNameLength = min => e => {
    	$msg.textContent = $input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : '';
    };
    
    // 함수를 반환하므로 결국 $input.onblur에 checkUserNameLength 함수가 반환하는 함수가 바인딩된다.
    $input.onblur = checkUserNameLength(5);
    $input.onblur = e => {
    	$msg.textContent = $input.value.length < 5? `이름은 5자 이상 입력해주세요` : '';
    };
    ```
    

# 커스텀 이벤트

## 커스텀 이벤트 생성

Event, UIEvent, MOuseEvent 같은 이벤트 생성자 함수를 호출하여 명시적으로 생성한 이벤트 객체는 **임의의 이벤트 타입을 지정할 수 있다.**

이처럼 **개발자의 의도**로 생성된 이벤트를 **커스텀 이벤트**라 한다.

- 이벤트 생성자 함수는 **첫 번째 인수**로 **이벤트 타입을 나타내는 문자열을 전달** 받는다.
    
    **기존 이벤트 타입을 사용**할 경우
    
    ```jsx
    // keyboardEvent 생성자 함수로 keyup 이벤트 타입의 커스텀 이벤트 객체 생성
    const keyboardEvent = new KeyboardEvent('keyup');
    console.log(keyboardEvent.type); //keyup
    ```
    
    **새로운 이벤트 타입**을 지정할 시 **CustomEvent 이벤트 생성자 함수**를 사용한다.
    
    ```jsx
    const customEvent = new CustomEvent('foo');
    console.log(customEvent.type); //foo
    ```
    
    이때 이벤트 객체는 버블링되지 않으며 preventDefault 메서드로 취소할 수도 없다.
    
    (customEvent.bubbles = false, customEvent.cancelable = false)
    

- 커스텀 이벤트 **두 번째 인수**로 프로퍼티 값을 지정할 수 있다.
    
    **bubbles**나 **cancelable** 프로퍼티를 true로 설정할 수 있다.
    
    ```jsx
    const customEvent = new MouseEvent('click', {
    	bubbles: true,
    	cancelable: true
    });
    ```
    
    이벤트 객체의 **고유 프로퍼티의 값**을 지정할 수 있다.
    
    ```jsx
    const mouseEvent = new MouseEvent('click', {
    	bubbles: true,
    	cancelable: true,
    	clientX: 50,
    	clientY: 100
    });
    
    console.log(mouseEvent.clientX); // 50
    console.log(mouseEvent.clientY); // 100
    
    const keyboardEvent = new KeyboardEvent('keyup', { key: 'Enter' });
    console.og(keyboardEvent.key); //Enter
    ```
    
- 이벤트 생성자 함수로 생성한 **커스텀 이벤트**의 `isTrusted` 프로퍼티 값은 언제나 **false**다.
    
    **사용자의 행위에 의해 발생한 이벤트**에 의해 생성된 이벤트 객체의 isTrusted 프로퍼티 값은 언제나 **true**다.
    
    ```jsx
    const customEvent = new InputEvent('foo');
    console.log(customEvent.isTrusted); // false
    ```
    

## 커스텀 이벤트 디스패치

커스텀 이벤트는 `dispatchEvent` 메서드로 **디스패치(이벤트를 발생시키는 행위)** 할 수 있다.

```jsx
const $button = document.querySelector('.btn');

//디스패치 이전에 이벤트 핸들러를 등록해야 한다.
$button.addEventListener('click', e => {
	console.log(e); // MouseEvent { isTrusted: false, screenX: 0, ...}
});

const customEvent = new MouseEvent('click');

// 커스텀 이벤트 디스패치 (동기 처리). click 이벤트 발생
$button.dispatchEvent(customEvent);
```

이벤트 핸들러는 **비동기**지만, dispatchEvent 메서드는 이벤트 핸들러를 동기 처리 방식으로 호출한다.

즉, dispatchEvent 메서드를 호출하면 이벤트에 바인딩 된 이벤트 핸들러를 직접 호출하는 것과 같다. 따라서 **디스패치 하기 이전에 이벤트 핸들러를 먼저 등록해야 한다.**

이벤트와 함께 전달하고 싶은 정보를 담은 detail 프로퍼티를 전달할 수 있다. 이 정보는 이벤트 객체의 detail 프로퍼티 (**e.detail**)에 담겨 전달 된다.

```jsx
$button.addEventListener('foo', e => {	alert(e.detail.message); // Hello
});
const customEvent = new CustomEvent('foo', {	detail: { message: 'Hello' }
});
```

커스텀 이벤트로 이벤트 핸들러를 등록할 경우 반드시 **`addEventListener`** 메서드 방식으로 등록해야 한다.

이벤트 핸들러 어트리뷰트/프로퍼티 방식을 사용할 수 없는 이유는  ‘on + 커스텀 이벤트 타입’으로 이루어진 이벤트 핸들러 어트리뷰트/프로퍼티가 요소 노드에 존재하지 않기 때문이다.

ex) ‘foo’라는 이벤트 타입으로 이벤트를 생성했을 때, ‘onfoo’라는 이벤트 핸들러 어트리뷰트/프로퍼티는 요소 노드에 존재하지 않는다.# 40장 - 이벤트2

# 이벤트 객체

이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성

생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.

이벤트 객체를 전달 받으려면 매개변수를 명시적으로 선언해야 한다.

아래 예제에선 e라는 이름으로 매개변수를 선언했으나 다른 이름을 사용해도 상관없다.

```jsx
<!DOCTYPE html>
<html>
<body>
<p>클릭하세요</p>
<em class="message">클릭한 곳의 좌표가 표시됩니다.</em>
<script>
	const $msg = document.querySelector('.message');
	// 클릭했을 때 마우스 좌표를 얻는 함수
	function showCoords(e) {
		$msg.textContent = `clientX : ${e.clientX}, clientY : ${e.clientY}`;
	}
	
	document.onclick = showCoords;
</script>
</body>
</html>
```

**이벤트 핸들러 어트리뷰트 방식**으로 이벤트 핸들러를 등록했다면 

**이벤트 핸들러의 첫 번째 매개변수 이름이 반드시 event**이어야 한다.

event가 아닌 다른 이름으로 매개변수를 선언할 경우 이벤트 객체를 전달받지 못한다.

```jsx
<!DOCTYPE html>
<html>
<body onclick=showCoords(event)>
<p>클릭하세요</p>
<em class="message">클릭한 곳의 좌표가 표시됩니다.</em>
<script>
	const $msg = document.querySelector('.message');
	// 클릭했을 때 마우스 좌표를 얻는 함수
	function showCoords(e) {
		$msg.textContent = `clientX : ${e.clientX}, clientY : ${e.clientY}`;
	}
	
	document.onclick = showCoords;
</script>
</body>
</html>
```

이벤트 객체

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled.png)

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled%201.png)

## 이벤트 객체의 상속 구조

이벤트가 발생하면 이벤트 타입에 따라 다양한 타입의 이벤트 객체가 생성된다.

Event 인터페이스에는 **모든 이벤트 객체의 공통 프로퍼티가 정의**되어 있고, 하위 인터페이스(FocusEvent, KEyboardEvent, MouseEvent, WheelEvent 등 )에 따라 **고유한 프로퍼티가 정의**되어 있다.

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled%202.png)

```jsx
const e = new InputEvent("change");
```

## 이벤트 객체의 공통 프로퍼티

**Event** 인터페이스에 정의되어 있는 이벤트 관련 프로퍼티는 파생 이벤트 객체에 상속된다.

| 공통 프로퍼티 | 설명 | 타입 |
| --- | --- | --- |
| type | 이벤트 타입 | string |
| target | 이벤트를 발생시킨 DOM 요소 | DOM 요소 노드 |
| currentTarget | 이벤트 핸들러가 바인딩된 DOM 요소 | DOM 요소 노드 |
| eventPhase | 이벤트 전파 단계 | number |
| bubbles | 이벤트를 버블링으로 전파하는지 여부 | boolean |
| cancelable | 이벤트의 기본 동작을 취소할 수 있는지 여부 | boolean |
| defaultPrevented | preventDefault 메서드를 호출해서 이벤트를 취소했는지 여부 | boolean |
| isTrusted | 사용자의 행위에 의해 발생한 이벤트인지 여부 | boolean |
| timeStamp | 이벤트가 발생한 시각 | number |

target 프로퍼티는 이벤트를 직접 건 요소를 가리킨다.

currentTarget 프로퍼티는 이벤트가 실행된 요소를 가리킨다.

```jsx
	$button.addEventListener('click', (e) => {
		console.log(e.target); // $button
		console.log(e.currentTarget ); // $button
	});
```

보통 target 프로퍼티와 currentTarget 프로퍼티는 동일한 DOM 요소를 가리키지만, 이벤트 위임을 사용한다면 서로 다른 DOM 요소를 가리킬 수 있음에 유의하자.

## 마우스 정보 취득

**MouseEvent** 생성자 함수(`click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseenter`, `mouseleave` 이벤트)의 고유 프로퍼티

- 마우스 포인터의 **좌표 정보**
    - screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
- **버튼 정보**
    - altKey, ctrlKey, shiftKey, button

## 키보드 정보 취득

**KeyboardEvent** 생성자 함수(`keydown`, `keyup`, `keypress` 이벤트)의 고유 프로퍼티

- altKey, ctrlKEy, metaKey, key, keyCode
    - key프로퍼티와 입력한 키의 대응관계  참고: [https://keycode.info](https://keycode.info/)

# 이벤트 전파

DOM 요소 노드에서 생성된 **이벤트 객체**는 이벤트를 발생시킨 DOM 요소인 **이벤트 타깃을 중심으로** **DOM 트리를 통해 전파**된다.

아래 이미지는 li에 클릭 이벤트를 줬을 때 이벤트 전파 과정을 보여준다.

![Untitled](40%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B32%206a21204ea19d47708ceae92a91ec87e4/Untitled%203.png)

이벤트 전파는 **전파 방향**에 따라 **3단계**로 구분된다.

1. 캡쳐링 단계 Capturing Phase : 이벤트가 상위 요소 → 하위 요소로 전파
2. 타깃 단계 Target Phase : 이벤트가 이벤트 타깃에 도달
3. 버블링 단계 Bubbling Phase : 이벤트가 하위 요소 → 상위 요소로 전파이벤트 핸들러 별 전파 단계

이벤트 핸들러 등록 방식에 따라 캐치할 수 있는 이벤트 전파 단계가 다르다.

1. 이벤트 핸들러 어트리뷰트 : 타깃 단계 / 버블링 단계 캐치
2. 이벤트 핸들러 프로퍼티 : 타깃 단계 / 버블링 단계 캐치
3. 이벤트 핸들러 addEventListener 메서드 : 타깃 단계 / 버블링 단계 / **캡쳐링** 단계(선별적 캐치)
    - 캡처링 단계를 캐치하려면 메서드의 **3번째 인수**를 **true**로 전달해야 한다.

이처럼 이벤트는 이벤트 타깃은 물론 상위 DOM요소에서도 캐치할 수 있다.

대부분의 이벤트는 캡처링과 버블링을 통해 전파되지만, 다음의 이벤트들은 버블링을 통해 전파되지 않는다.

이벤트 객체의 공통 프로퍼티 event.bubbles 는 false이다.

- **포커스 이벤트**: focus / blur
- **리소스 이벤트:** load / unload / abort / error
- **마우스 이벤트:** mouseenter / mouseleave

위 이벤트들은 버블링되지 않으므로 이벤트 타깃의 상위 요소에서 이벤트를 캐치하려면 캡처링 단계의 이벤트를 캐치 해야 한다. 하지만 반드시 위 이벤트를 상위 요소에서 캐치해야 한다면 대체할 수 있는 이벤트가 존재한다.

 아래 이벤트는 버블링을 통해 전파되므로 이벤트 객체의 공통 프로퍼티 event.bubbles 는 true이다.

- **포커스 이벤트**: focusin / focusout
- **마우스 이벤트:** mouseover / mouseout

```jsx
<!DOCTYPE html>
...
<body>
<p>
		버블링과 캡쳐링 이벤트 
		<button>버튼</button>
</p>
<script>
	// 버블링 단계의 이벤트 캐치
	document.body.addEventListener('click', () => {
		console.log('Handler for body');
	});
	
	// 캡처링 단계의 이벤트 캐치
	// addEventListener의 세 번재 인수 true를 전달하여 캡쳐링 단계에서 이벤트 캐치
	document.queerySelector('p').addEventListener('click', () => {
		console.log('Handler for paragraph');
	}, true);
	
	// 타깃 단계의 이벤트 캐치
	document.querySelector('button').addEventListener('click', () => {
		console.log('Handler for button');
	})
</script>
</body>
...
```

버튼 요소를 클릭할 경우

```jsx
Handler for paragraph // 캡처링 단계의 이벤트 캐치
Handler for button // 타깃 단계의 이벤트 캐치
Handler for body // 버블링 단계의 이벤트 캐치
```

p 요소를 클릭할 경우

```jsx
Handler for paragraph // 캡처링 단계의 이벤트 캐치
Handler for body // 버블링 단계의 이벤트 캐치
```

# 이벤트 위임

여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 **하나의 상위 DOM 요소에 이벤트 핸들러를 등록**하는 방법을 말한다.

이벤트 위임을 통해 이벤트를 등록할 경우 이벤트 객체의 target 프로퍼티를 사용하여 원하는 요소에 이벤트를 발생시킨다.

```jsx
...
<body>
	<ul id="fruits">
		<li>banana</li>
		<li>apple</li>
		<li>strawberry</li>
	</ul>
	
	<script>
		const fruits = document.getElementById('fruits');
		fruits.onclick = active;
		
		function active({target}) {
			if(!target.matches('#fruits > li')) return;
			
			[...$fruits.children].forEach($fruit => {
				$fruit.classList.toggle('active', $fruit === target);
			})
		}
	</script>
</body>
...
```

# DOM 요소의 기본 동작 조작

## DOM 요소의 기본 동작 중단

event 객체의 `preventDefault` 메서드는 **DOM 요소의 기본 동작을 중단**시킨다.

```jsx
document.queryselector('a').onclick = e => {
	// a 요소의 기본 동작을 중단한다.
	e.preventDefault();
}
```

## 이벤트 전파 방지

event 객체의 `stopPropagation` 메서드는 **이벤트 전파를 중지 시킨다**.

```jsx
// 이벤트 위임. 클릭된 하위 버튼 요소의 color를 변경한다.
document.queryselector('.container').onclick = ({ target }) => {
	if(!target.matches('.container > button')) return;
	target.style.color = 'red';
}

// .btn2 요소는 이벤트를 전파하지 않으므로 상위 요소에서 이벤트를 캐치할 수 없다.
document.queryselector('.btn2').onclick = e => {
	e.stopPropagation();
	e.target.style.color = "blue";
}
```

# 이벤트 핸들러 내부의 this

## 이벤트 핸들러 어트리뷰트 방식

이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 암묵적으로 이벤트 핸들러의 문으로 생성된다. 이벤트 핸들러에 의해 **일반 함수로 호출되며** 일반 함수 내부의 **this**는 **전역 객체 window를 가리킨다.**

```jsx
<button onclick="handleclick()">Click Me</button>

...
function handleClick() {
	console.log(this); //**window**
}
```

이벤트 핸들러를 호출할 때 인수로 전달한 this는 **이벤트를 바인딩한 DOM 요소를 가리킨다**.

인수로 전달한 this는 **암묵적으로 생성된 이벤트 핸들러 내부의 this**다

```jsx
<button onclick="handleclick(this)">Click Me</button>

...
function handleClick(button) {
	console.log(button); // button 요소
	console.log(this); // window
}
```

## 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 **DOM 요소**를 가리킨다.

1. 이벤트 핸들러 프로퍼티 방식
    
    ```jsx
    $button1.onClick = function (e) {
    	console.log(this); // $button1
    	console.log(e.currentTarget); // $button1
    	console.log(this === e.currentTarget); // true
    }
    ```
    
2. addEventListener 메서드 방식
    
    ```jsx
    $button2.addEventListener('click', function (e) {
    	console.log(this); // $button2
    	console.log(e.currentTarget); // $button2
    	console.log(this === e.currentTarget); // true
    }
    ```
    

**화살표 함수**로 정의한 이벤트 핸들러 내부의 this는 **상위 스코프의 this를 가리킨다**. 

화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.

1. 이벤트 핸들러 프로퍼티 방식
    
    ```jsx
    $button1.onClick = e => {
    	console.log(this); // window
    	console.log(e.currentTarget); // $button1
    	console.log(this === e.currentTarget); // false
    }
    ```
    
2. addEventListener 메서드 방식
    
    ```jsx
    $button2.addEventListener('click', e => {
    	console.log(this); // window
    	console.log(e.currentTarget); // $button2
    	console.log(this === e.currentTarget); // false
    }
    ```
    

**클래스**에서 이벤트 핸들러를 바인딩할 경우 this에 주의해야 한다.

**이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리키기 때문에** increase 메서드 내부의 this는 this.$button을 가리킨다.

```jsx
class App {
	constructor() {
		this.$button = document.querySelector('.btn');
		this.count = 0;

		this.$button.onclick = this.increase;
	}

	increase() {
		// 이벤트 핸들러 increase 내부의 this는 DOM 요소(this.$button)를 가리킨다.
		// this.$button은 this.$button.$button과 같다.
		this.$button.textContent = ++this.count;
		//TypeError: Cannot set property 'textContent' of undefined
	}
}
```

1. **bind 메서드 사용하여 해결**

increase 메서드를 이벤트 핸들러로 바인딩할 때 `bind` 메서드를 사용해 increase 메서드 내부의 this가 클래스가 생성할 인스턴스를 가리키도록 해야 한다.

```jsx
class App {
	constructor() {
		this.$button = document.querySelector('.btn');
		this.count = 0;

		this.$button.onclick = this.increase.bind(this);
	}

	increase() {
		this.$button.textContent = ++this.count;
	}
}
```

1.  **화살표 함수 사용하여 해결**

화살표 함수를 이벤트 핸들러로 등록하여 이벤트 핸들러 내부의 this가 인스턴스를 가리키도록 할 수 있다.

이때 이벤트 핸들러 increase는 프로토타입 메서드가 아닌 **인스턴스 메서드가 된다.**

```jsx
class App {
	constructor() {
		this.$button = document.querySelector('.btn');
		this.count = 0;

		this.$button.onclick = this.increase;
	}

	// inscrease는 인스턴스 메서드이며, 내부의 this는 인스턴스를 가리킨다.
	increase = () => this.$button.textContent = ++this.count;
}
```

# 이벤트 핸들러에 인수 전달

- 이벤트 핸들러 어트리뷰트 방식
    
    함수 호출문으로 인수를 전달한다
    
    ```jsx
    const checkUserNameLength = min => {
    	$msg.textContent = $input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : '';
    };
    
    $input.onblur = function() {
        checkUserNameLength(5);
    };
    
    $input.onblur = () => checkUserNameLength(5);
    ```
    

- 이벤트 핸들러 프로퍼티 방식 & addEventListener 메서드
    
    브라우저가 이벤트 핸들러를 호출하기 때문에 **함수 자체**를 등록해야 하므로 인수를 전달할 수 없다. 대신 이벤트 핸들러 내부에서 **함수를 호출하면서 인수를 전달할 수 있다.**
    
    ```jsx
    const checkUserNameLength = min => {
    	$msg.textContent = $input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : '';
    };
    
    $input.addEventListener('blur', () => {checkUserNameLength(5)})'
    ```
    
    혹은 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수 있다.
    
    ```jsx
    const checkUserNameLength = min => e => {
    	$msg.textContent = $input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : '';
    };
    
    // 함수를 반환하므로 결국 $input.onblur에 checkUserNameLength 함수가 반환하는 함수가 바인딩된다.
    $input.onblur = checkUserNameLength(5);
    $input.onblur = e => {
    	$msg.textContent = $input.value.length < 5? `이름은 5자 이상 입력해주세요` : '';
    };
    ```
    

# 커스텀 이벤트

## 커스텀 이벤트 생성

Event, UIEvent, MOuseEvent 같은 이벤트 생성자 함수를 호출하여 명시적으로 생성한 이벤트 객체는 **임의의 이벤트 타입을 지정할 수 있다.**

이처럼 **개발자의 의도**로 생성된 이벤트를 **커스텀 이벤트**라 한다.

- 이벤트 생성자 함수는 **첫 번째 인수**로 **이벤트 타입을 나타내는 문자열을 전달** 받는다.
    
    **기존 이벤트 타입을 사용**할 경우
    
    ```jsx
    // keyboardEvent 생성자 함수로 keyup 이벤트 타입의 커스텀 이벤트 객체 생성
    const keyboardEvent = new KeyboardEvent('keyup');
    console.log(keyboardEvent.type); //keyup
    ```
    
    **새로운 이벤트 타입**을 지정할 시 **CustomEvent 이벤트 생성자 함수**를 사용한다.
    
    ```jsx
    const customEvent = new CustomEvent('foo');
    console.log(customEvent.type); //foo
    ```
    
    이때 이벤트 객체는 버블링되지 않으며 preventDefault 메서드로 취소할 수도 없다.
    
    (customEvent.bubbles = false, customEvent.cancelable = false)
    

- 커스텀 이벤트 **두 번째 인수**로 프로퍼티 값을 지정할 수 있다.
    
    **bubbles**나 **cancelable** 프로퍼티를 true로 설정할 수 있다.
    
    ```jsx
    const customEvent = new MouseEvent('click', {
    	bubbles: true,
    	cancelable: true
    });
    ```
    
    이벤트 객체의 **고유 프로퍼티의 값**을 지정할 수 있다.
    
    ```jsx
    const mouseEvent = new MouseEvent('click', {
    	bubbles: true,
    	cancelable: true,
    	clientX: 50,
    	clientY: 100
    });
    
    console.log(mouseEvent.clientX); // 50
    console.log(mouseEvent.clientY); // 100
    
    const keyboardEvent = new KeyboardEvent('keyup', { key: 'Enter' });
    console.og(keyboardEvent.key); //Enter
    ```
    
- 이벤트 생성자 함수로 생성한 **커스텀 이벤트**의 `isTrusted` 프로퍼티 값은 언제나 **false**다.
    
    **사용자의 행위에 의해 발생한 이벤트**에 의해 생성된 이벤트 객체의 isTrusted 프로퍼티 값은 언제나 **true**다.
    
    ```jsx
    const customEvent = new InputEvent('foo');
    console.log(customEvent.isTrusted); // false
    ```
    

## 커스텀 이벤트 디스패치

커스텀 이벤트는 `dispatchEvent` 메서드로 **디스패치(이벤트를 발생시키는 행위)** 할 수 있다.

```jsx
const $button = document.querySelector('.btn');

//디스패치 이전에 이벤트 핸들러를 등록해야 한다.
$button.addEventListener('click', e => {
	console.log(e); // MouseEvent { isTrusted: false, screenX: 0, ...}
});

const customEvent = new MouseEvent('click');

// 커스텀 이벤트 디스패치 (동기 처리). click 이벤트 발생
$button.dispatchEvent(customEvent);
```

이벤트 핸들러는 **비동기**지만, dispatchEvent 메서드는 이벤트 핸들러를 동기 처리 방식으로 호출한다.

즉, dispatchEvent 메서드를 호출하면 이벤트에 바인딩 된 이벤트 핸들러를 직접 호출하는 것과 같다. 따라서 **디스패치 하기 이전에 이벤트 핸들러를 먼저 등록해야 한다.**

이벤트와 함께 전달하고 싶은 정보를 담은 detail 프로퍼티를 전달할 수 있다. 이 정보는 이벤트 객체의 detail 프로퍼티 (**e.detail**)에 담겨 전달 된다.

```jsx
$button.addEventListener('foo', e => {	alert(e.detail.message); // Hello
});
const customEvent = new CustomEvent('foo', {	detail: { message: 'Hello' }
});
```

커스텀 이벤트로 이벤트 핸들러를 등록할 경우 반드시 **`addEventListener`** 메서드 방식으로 등록해야 한다.

이벤트 핸들러 어트리뷰트/프로퍼티 방식을 사용할 수 없는 이유는  ‘on + 커스텀 이벤트 타입’으로 이루어진 이벤트 핸들러 어트리뷰트/프로퍼티가 요소 노드에 존재하지 않기 때문이다.

ex) ‘foo’라는 이벤트 타입으로 이벤트를 생성했을 때, ‘onfoo’라는 이벤트 핸들러 어트리뷰트/프로퍼티는 요소 노드에 존재하지 않는다.
