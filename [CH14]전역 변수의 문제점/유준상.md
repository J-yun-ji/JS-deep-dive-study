# [14장] 전역 변수의 문제점 정리

## 변수의 생명 주기

---

변수는 선언 ⇒ 할당 ⇒ 소멸의 과정을 거칩니다.

소멸과 함께 변수의 생명 주기는 끝납니다.

하지만, 전역 변수와 지역 변수의 생명 주기에는 차이가 존재합니다.

```jsx
var x = 'global';

function foo() {
	console.log(x); // 'local'
	var x = 'local';
}

foo();
console.log(x); // 'global'
```

변수 호이스팅은 변수 선언이 스코프의 최상단으로 끌어올려지는 효과입니다.

함수 내부의 console.log(x); 는 호이스팅된 지역 변수 x 를 참조하고,

함수 바깥의 console.log(x); 는 foo(); 의 실행이 끝난 시점이므로, 지역변수는 소멸되어 생명 주기가 끝났습니다.

따라서, 전역 변수 x를 참조하게 됩니다.

전역 변수 생명 주기 === 애플리케이션 생명 주기 이므로,

애플리케이션이 종료할 때까지 전역 변수는 유효하게 됩니다.

## 전역 변수의 문제점

---

- 긴 생명 주기
    
    
    |  | 전역 변수 | 지역 변수 |
    | --- | --- | --- |
    | 생명 주기 | 길다 | 짧다 |
    | 메모리 리소스 | 오랜 기간 소비 | 짧은 기간 소비 |
    | 상태 변경 | 변경 가능한 시간이 길고 변경 가능성도 높음 | 변경 가능한 시간이 짧고 변경 가능성도 낮음 |
- 스코프 체인 상에서 종점에 존재
    
    전역 변수는 **스코프 체인 상에서 종점**에 존재합니다.
    
    ⇒ 전역 변수의 검색 속도가 가장 느립니다.
    
- 네임스페이스 오염
    
    네임스페이스(Namespace)는 구분이 가능하도록 정해놓은 범위나 영역을 의미합니다.
    
    <aside>
    💡 **네임스페이스 개념 예시**
    김상덕 씨라는 인물을 찾으려고 할 때, 그 인물에 대한 자세한 정보 없이는 찾을 수가 없습니다.
    대한민국, 서울시, xx구, oo동에 사는 김상덕 씨
    와 같이 자세한 정보가 있어야만 그 인물을 찾을 수 있습니다.
    **이러한 “자세한 정보”를 Javascript에서는 Namespace라고 부릅니다.**
    
    </aside>
    
    어떤 파일에 전역 변수를 선언했을 때, 다른 파일에서도 그 전역 변수를 참조하는 것이 가능해집니다.
    
    **⇒ 의도치 않은 전역 변수의 값 변경 ⇒ 결과 예측이 힘들어짐**
    

## 전역 변수의 사용을 억제하는 방법

---

1. 즉시 실행 함수(IIFE)

함수 정의와 실행이 동시에 일어나는 즉시 실행 함수는 한 번 실행하고 다시는 실행되지 않습니다.

이러한 IIFE의 특징을 이용해 변수를 지역 스코프로 한정하고 실행이 끝나자마자 소멸하게 합니다.

```jsx
// 전역 변수의 문제점
var num = 1;

// ...

num++;
console.log(num); // 2 (의도치 않게 값이 변경됨)
```

```jsx
// IIFE 활용
(function () {
	var num = 1;
	// ...
}());

num++; // ReferenceError: num is not defined
console.log(num); // ReferenceError: num is not defined
```

1. 네임스페이스 객체

전역 네임스페이스 역할의 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법입니다.

```jsx
// 네임스페이스 객체 활용
const MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Lee';

console.log(MYAPP.name); // Lee
```

1. 모듈 패턴

모듈 패턴은 관련이 있는 변수와 함수를 즉시 실행 함수로 함께 감싸 하나의 모듈을 만듭니다.

모듈 패턴은 클로저에 기반합니다.

<aside>
💡 **캡슐화와 정보 은닉**
캡슐화는 프로퍼티(객체의 상태) + 메서드(동작)을 하나로 묶은 것
정보 은닉은 캡슐화와 밀접한 관계에 있습니다.
캡슐화를 사용하면 특정 프로퍼티와 메서드를 외부로 노출시키지 않기 때문에 정보 은닉 효과가 있습니다.

</aside>

```jsx
var Counter = (function () {
	var num = 0; // private member
	
	// 객체에 public member를 프로퍼티로 추가 => 반환
	return {
		increase() { return ++num; },
		decrease() { return --num; },
	};
}());

console.log(Counter.num); // undefined (private member는 외부로 노출하지 않는다)
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

즉시 실행 함수는 객체(public member)를 return 합니다.

모듈 패턴을 사용하면 외부로 노출되지 않은 변수(private member)를 외부 참조 및 변경으로부터 막을 수 있습니다. (정보 은닉)

1. ES6 모듈

script 태그에 type=”module” 속성을 추가하면 로드된 자바스크립트 파일이 하나의 모듈로서 동작합니다. (확장자는 .mjs 사용)

ES6 모듈은 트랜스파일링이나 번들링이 추가로 필요하므로, Webpack이라는 모듈 번들러 도입이 좀 더 일반적이라고 합니다.