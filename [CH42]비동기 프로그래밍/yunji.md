# 42장. 비동기 프로그래밍

## 📌 동기 처리와 비동기 처리

- 함수의 실행 순서는 **실행 컨텍스트 스택**으로 관리함
    - 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문
- **자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가짐**
    - 함수를 실행할 수 있는 창구가 단 **하나**이며 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 의미
- 실행 컨텍스트 스택의 최상위 요소인 ‘실행 중인 실행 컨텍스트’를 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들임
- 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드(single thread)** 방식
    - **싱글 스레드** :  한 번에 하나의 태스크만 실행할 수 있기 때문에 처리와 시간이 걸리는 태스크를 실행하는 경우 **블로킹(blocking** 작업 중단)이 발생함
    
    ```jsx
    // sleep 함수는 일정 시간(dealy)이 경과한 이후에 콜백(func) 함수 호출
    function sleep(func, delay) {
    	// Date.now()는 현재 시간을 숫자(ms)로 반환.
    	const delayUntil = Date.now() + delay;
    	
    	// 현재 시간에 delay를 더한 delayUntil이 현재 시간보다 작으면 계속 반복
    	while (Date.now() < delayUntil);
    	
    	// delay 경과한 이후에 콜백 함수(func) 호출.
    	func();
    }
    
    function foo() {
    	console.log('foo');
    }
    
    function bar() {
    	console.log('bar');
    }
    
    // sleep 함수는 3초 이상 실행됨
    sleep(foo, 3 * 1000);
    
    // bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 블로킹됨
    bar();
    // (3초 경과 후) foo 호출 -> bar 호출
    ```
    
- 위 코드의 sleep 함수는 3초 후에 foo 함수를 호출함
    - bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 호출되지 못하고 **블로킹**됨
- 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식 → **동기 처리(synchronous)**
    - **장점** : 태스크를 순서대로 하나씩 처리하므로 실행 순서 보장
    - **단점** : 앞선 태스크가 종료할 때까지 이후 태스크들은 블로킹
- **setTimeout을 사용하면 ?**
    
    ```jsx
    function foo() {
    	console.log('foo');
    }
    
    function bar() {
    	console.log('bar');
    }
    
    // 타이머 함수 setTimeout은 일정 시간이 경과한 이후에 콜백 함수 foo를 호출함
    /// setTimeout은 bar 함수를 블로킹하지 않음
    setTimeout(foo, 3 * 1000);
    bar();
    ```
    
- **setTimeout 함수**는 sleep 함수와 유사하게 일정 시간 경과 후 콜백 함수를 호출하지만 setTimeout 함수 이후의 태스크를 블로킹하지 않고 곧바로 실행
- 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식 → **비동기(asynchronous) 처리**
    - **장점** : 현재 실행 중인 태스크가 종료되지 않을 상태여도 다음 태스크를 곧바로 실행하므로 블로킹 발생 X
    - 단점 : 태스크의 실행 순서 보장 X
- **비동기 함수**는 전통적으로 콜백 패턴 사용
- 비동기 처리를 위한 콜백 패턴은 헬(call back hell)을 발생시켜 가독성을 나쁘게 하고 비동기 처리 중 발생한 에러의 예외 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는데도 한계가 있음
    - 45절 프로미스에서 자세히…
- 타이머 함수인 setTimeout과 setInterval, HTTP 요청, 이벤트 핸들러는 **비동기 처리 방식**으로 동작

## 📌 이벤트 루프와 태스크 큐

- 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴짐
    - 자바스크립트의 동시성을 지원하는 것 → **이벤트 루프(event loop)**
- 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나
- 구글의 V8 자바스크립트 엔진을 비롯한 대부분의 **자바스크립트 엔진**은 크게 **2개**의 영역으로 구분
    - **콜 스택(call stack)**
        - 소스 코드 평가 과정에서 생선된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택
    - **힙(heap)**
        - 객체가 저장되는 메모리 공간
        - 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체 참조
- **브라우저 환경**은 태스크 큐와 이벤트 루프 제공
    - **태스크 큐(task queue)**
        - setTimeout, setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역임
    - **이벤트 루프(event loop)**
        - 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인. 만일 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킴
- 비동기 함수인 setTimeout의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면 즉, 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 비로소 콜 스택에 푸시되어 실행됨
- **자바스크립트 엔진**은 싱글 스레드로 동작하지만 **브라우저**는 멀티 스레드로 동작함
